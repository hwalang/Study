# 영어가 싫어요
**[영어가 싫어요](https://school.programmers.co.kr/learn/courses/30/lessons/120894)**   

풀었지만, std를 잘 활용하지 못해서 for문을 3개를 사용했다   

# 풀이
## ME
```cpp
#include <string>
#include <vector>
#include <unordered_map>

using namespace std;

unordered_map<string, char> m = {
    {"one", '1'}, {"two", '2'}, {"six", '6'}, 
    {"zero", '0'}, {"four", '4'}, {"five", '5'}, {"nine", '9'}, 
    {"three", '3'}, {"seven", '7'}, {"eight", '8'}
};

long long solution(string numbers) {
    string str_answer = "";
    for (int i = 0; i < numbers.size(); ++i) {
        for (auto& pair : m) {
            for (int j = 3; j <= 5; ++j) {
                if (numbers.substr(i, j) == pair.first) {
                    numbers.replace(i, j," ");
                    str_answer += pair.second;
                }
            }
        }
    }
    long long answer = stoll(str_answer);
    return answer;
}
```
1. unordered_map이 key를 찾는 과정이 O(1)이기 때문에 사용했지만, for문으로 순회했기 때문에 일반 map을 사용해도 됐다고 생각
2. numbers를 순회
   1. 순서대로 문자열을 판단하여 str_answer에 정수 문자열을 추가
      1. 0번 index에서 처음엔 3글자씩 substr을 추출하여 map에서 찾는다, 최대 5글자까지 확장하면서 판단
      2. key에 대응하는 문자열이 있다면, numbers에서 해당 문자열을 공백으로 대체하고 str_answer에 대응하는 value 정수 문자열을 추가
3. str_answer를 long long으로 변환

<br>

## Other
```cpp
#include <string>
#include <vector>

using namespace std;

long long solution(string numbers) {
    long long answer = 0;
    vector<string> num = {
        "zero", "one", "two", "three", "four", "five",
        "six", "seven", "eight", "nine"
    };
    int tmp;

    for (int i=0; i<num.size(); i++)
    {
        while ((tmp = numbers.find(num[i])) != string::npos)
        {
            numbers.replace(tmp, num[i].size(), to_string(i));
        }
    }
    answer = stoll(numbers);
    return answer;
}
```