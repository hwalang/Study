
[ 문제 링크 ](https://school.programmers.co.kr/learn/courses/30/lessons/181832)<br>
# 정수를 나선형으로 배치하기

힘들게 풀었기 때문에 다음에 다시 한 번 더 풀어본다<br>
다른 사람의 풀이를 봤는데, 내 방법이 가장 직관적이어서 이를 메모한다.<br>

<br>

# 풀이
## ME
```cpp
#include <vector>
using namespace std;

vector<vector<int>> solution(int n)
{
  vector<vector<int>> vec(n, vector<int>(n));
  const pair<int, int> dir[] = { {0, 1}, {1, 0}, {0, -1}, {-1, 0} };      // 동남서북

  int r_idx = 0;
  int c_idx = 0;
  int d_idx = 0;

  int value = 1;
  vec[r_idx][c_idx] = value;
  int cnt = n * n - 1;

  while (cnt) {
    int nr_idx = r_idx + dir[d_idx].first;
    int nc_idx = c_idx + dir[d_idx].second;
    if ((nr_idx >= n || nc_idx >= n || nr_idx < 0 || nc_idx < 0) || vec[nr_idx][nc_idx]) {
      d_idx = (d_idx + 1) % 4;
      continue;
    }

    vec[nr_idx][nc_idx] = ++value;
    r_idx = nr_idx;
    c_idx = nc_idx;
    --cnt;
  }

  return vec;
}
```
처음에는 row 방향과 col 방향을 function으로 만들려고 헀지만, 방향이 동서남북이라서 적절하지 않았다<br>
그래서 `2차원 배열에서 동서남북으로 이동할 수 있는 방향 배열을 정의`했다.<br>

그 다음엔 `방향을 언제 변경하는지에 대한 조건이 필요`했다.<br>
이를 방향과 현재 idx를 이용하여 다음 idx가 vec의 범위를 넘어가는 경우로 삼았고, 나중에 다음 value가 0이 아닌 경우도 추가했다.<br>
방향을 변경할 때, 4가지 방향만 존재하기 때문에 modular 연산을 이용했다<br>

이제 `loop를 언제 종료할지` 알아야 했다<br>
이는 방향을 변경할 때를 제외하고, value를 vec에 저장한 경우에만 cnt를 줄여서 총 n * n 번의 연산을 수행하도록 했다<br>
하지만 [0][0]에 1을 저장하고 시작했기 때문에 나중에 cnt를 n * n - 1로 수정했다<br>

`loop에서는 다음 idx의 값을 변경`하기 떄문에 이를 기준으로 value와 idx를 판단했다<br>