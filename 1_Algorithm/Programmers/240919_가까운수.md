# 가까운 수
**[ 가까운 수 ](https://school.programmers.co.kr/learn/courses/30/lessons/120890)**   

if문이 많아질수록 스파게티 코드가 될 가능성이 높아지고, 이로 인해 유지 보수성이 좋지 않다   
이번 문제를 맞췄지만, if문 4개를 사용했기에 풀었다고 생각하지 않는다   
다른 사람은 더 좋은 방법을 사용했기에 이를 기록한다   

<br>

# 풀이

## ME
```cpp
#include <vector>
#include <algorithm>

using namespace std;

int solution(vector<int> array, int n) {
    // 1. 정렬
    // 2. find(n)으로 n이 없으면 다음 단계
    // 3. n보다 큰 수가 나오면 이전 인덱스와 현재 인덱스의 element를 비교하여 무엇이 더 가까운지 판단
    // 4. n보다 큰 수가 나오지 않으면, 순회가 끝냈다는 의미이므로 마지막 원소를 반환
    sort(array.begin(), array.end());
    for (int i = 0; i < array.size(); ++i) {
        if (array[i] == n) return array[i];
        if (array[i] > n && i > 0) return (n - array[i - 1] > array[i] - n) ? array[i] : array[i - 1];
        if (array[i] > n && i == 0) return array[i];
        if (i == array.size() - 1) return array[i];
        
    }
}
```
1. vector를 정렬한다
2. 정렬된 vector를 순회하면서 n을 찾는다
3. 만약 n보다 큰 수가 나오면, 이전 인덱스와 현재 인덱스의 element를 비교하여 무엇이 더 가까운지 판단한다
4. n보다 큰 수가 나오지 않으면, 순회가 끝났다는 의미이므로 마지막 원소를 반환한다
5. 만약 n보다 큰 수가 0번 index에 위치한다면, 해당 element를 반환한다

<br>

## Other
```cpp
#include <vector>
#include <cmath>
#include <algorithm>

using namespace std;

int solution(vector<int> array, int n)
{
    int answer = 0;
    int gap = 100;
    sort(array.begin(), array.end(), greater<int>());
    for (int i = 0; i < array.size(); ++i) {
      if (abs(array[i] - n) <= gap) { 
        answer = array[i]; 
        gap = abs(array[i] - n); 
      }
    }
    return answer;
}
```
만약 n 주위의 값들의 거리가 같다면, 작은 element를 선택하기 때문에 내림차순으로 정렬한다   
현재 index의 element와 n의 차이가 gap보다 같거나 작으면, answer와 gap를 갱신하기 때문이다   
즉, 현재 index로 갱신하기 때문에 내림차순으로 정렬한다   
